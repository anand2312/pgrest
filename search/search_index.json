{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"pgrest-client # A Python Client library for PostgREST APIs. Note This is a fork of the Supabase Community Postgrest Client . I am maintaining this fork with my changes for another project , that will use this under the hood. Installation # pip install pgrest or with Poetry poetry add pgrest Head over to the quickstart , or the examples!","title":"Home"},{"location":"#pgrest-client","text":"A Python Client library for PostgREST APIs. Note This is a fork of the Supabase Community Postgrest Client . I am maintaining this fork with my changes for another project , that will use this under the hood.","title":"pgrest-client"},{"location":"#installation","text":"pip install pgrest or with Poetry poetry add pgrest Head over to the quickstart , or the examples!","title":"Installation"},{"location":"changelog/","text":"Changelog # v0.7.0 # New Features # Added new form of querying: I call it simple querying Simple querying adds support for joining filters using AND/OR, which was previously unsupported. Add better type annotations to improve user experience. Add better examples v0.6.0 # New Features # More documentation is online Added better type annotations Added insert_many method v0.5.0 # Initial release. I messed up and released at 0.5.0. New features # New features that have been added on top of whatever the original library had: Sync Client, although I am not sure if I'll be keeping it around Filters are now allowed on .rpc that returns tables.","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#v070","text":"","title":"v0.7.0"},{"location":"changelog/#new-features","text":"Added new form of querying: I call it simple querying Simple querying adds support for joining filters using AND/OR, which was previously unsupported. Add better type annotations to improve user experience. Add better examples","title":"New Features"},{"location":"changelog/#v060","text":"","title":"v0.6.0"},{"location":"changelog/#new-features_1","text":"More documentation is online Added better type annotations Added insert_many method","title":"New Features"},{"location":"changelog/#v050","text":"Initial release. I messed up and released at 0.5.0.","title":"v0.5.0"},{"location":"changelog/#new-features_2","text":"New features that have been added on top of whatever the original library had: Sync Client, although I am not sure if I'll be keeping it around Filters are now allowed on .rpc that returns tables.","title":"New features"},{"location":"quickstart/","text":"Getting Started # import asyncio from pgrest import Client async def main (): async with Client ( \"http://localhost:3000\" ) as client : r = await client . from_ ( \"countries\" ) . select ( \"*\" ) . execute () # execute returns a two-tuple, where the first element is the data. countries = r [ 0 ] asyncio . run ( main ()) Create # await client . from_ ( \"countries\" ) . insert ({ \"name\" : \"Vi\u1ec7t Nam\" , \"capital\" : \"H\u00e0 N\u1ed9i\" }) . execute () Bulk Insert # rows = [{ \"name\" : \"India\" , \"capital\" : \"New Delhi\" }, { \"name\" : \"Japan\" , \"capital\" : \"Tokyo\" }] await client . from_ ( \"countries\" ) . insert_many ( rows ) . execute () Read # r = await client . from_ ( \"countries\" ) . select ( \"id\" , \"name\" ) . execute () countries = r [ 0 ] Update # await client . from_ ( \"countries\" ) . update ({ \"capital\" : \"H\u00e0 N\u1ed9i\" }) . eq ( \"name\" , \"Vi\u1ec7t Nam\" ) . execute () Delete # await client . from_ ( \"countries\" ) . delete () . eq ( \"name\" , \"Vi\u1ec7t Nam\" ) . execute () Stored procedures (RPC) # r = await client . rpc ( \"hello_world\" ) . execute () r = await client . rpc ( \"echo_city\" , params = { \"name\" : \"The Shire\" }) . execute () All above methods have synchronous counterparts in pgrest._sync_client.SyncClient , although the asynchronous functionality is the focus of this library, and is recommended to be used.","title":"Quickstart"},{"location":"quickstart/#getting-started","text":"import asyncio from pgrest import Client async def main (): async with Client ( \"http://localhost:3000\" ) as client : r = await client . from_ ( \"countries\" ) . select ( \"*\" ) . execute () # execute returns a two-tuple, where the first element is the data. countries = r [ 0 ] asyncio . run ( main ())","title":"Getting Started"},{"location":"quickstart/#create","text":"await client . from_ ( \"countries\" ) . insert ({ \"name\" : \"Vi\u1ec7t Nam\" , \"capital\" : \"H\u00e0 N\u1ed9i\" }) . execute ()","title":"Create"},{"location":"quickstart/#bulk-insert","text":"rows = [{ \"name\" : \"India\" , \"capital\" : \"New Delhi\" }, { \"name\" : \"Japan\" , \"capital\" : \"Tokyo\" }] await client . from_ ( \"countries\" ) . insert_many ( rows ) . execute ()","title":"Bulk Insert"},{"location":"quickstart/#read","text":"r = await client . from_ ( \"countries\" ) . select ( \"id\" , \"name\" ) . execute () countries = r [ 0 ]","title":"Read"},{"location":"quickstart/#update","text":"await client . from_ ( \"countries\" ) . update ({ \"capital\" : \"H\u00e0 N\u1ed9i\" }) . eq ( \"name\" , \"Vi\u1ec7t Nam\" ) . execute ()","title":"Update"},{"location":"quickstart/#delete","text":"await client . from_ ( \"countries\" ) . delete () . eq ( \"name\" , \"Vi\u1ec7t Nam\" ) . execute ()","title":"Delete"},{"location":"quickstart/#stored-procedures-rpc","text":"r = await client . rpc ( \"hello_world\" ) . execute () r = await client . rpc ( \"echo_city\" , params = { \"name\" : \"The Shire\" }) . execute () All above methods have synchronous counterparts in pgrest._sync_client.SyncClient , although the asynchronous functionality is the focus of this library, and is recommended to be used.","title":"Stored procedures (RPC)"},{"location":"examples/queries/filter-queries/","text":"Filter queries # This is the original style of queries established by existing Supabase client side libraries, including the Javascript client. It lets you chain multiple methods to form complex filters, although this can become a little untidy at times. Moreover, this form of querying does not let you combine multiple conditions using AND/OR clauses (currently). Tip Refer the PostgREST docs for more info about operators. res = await client . from_ ( \"countries\" ) . select ( \"*\" ) . filter ( \"name\" , \"eq\" , \"India\" ) . execute () res = await client . from_ ( \"cities) . select ( \"name, country_id\" ) . gte ( \"population\" , 1000 ) . lt ( \"population\" , 10000 )","title":"Filter-style Queries"},{"location":"examples/queries/filter-queries/#filter-queries","text":"This is the original style of queries established by existing Supabase client side libraries, including the Javascript client. It lets you chain multiple methods to form complex filters, although this can become a little untidy at times. Moreover, this form of querying does not let you combine multiple conditions using AND/OR clauses (currently). Tip Refer the PostgREST docs for more info about operators. res = await client . from_ ( \"countries\" ) . select ( \"*\" ) . filter ( \"name\" , \"eq\" , \"India\" ) . execute () res = await client . from_ ( \"cities) . select ( \"name, country_id\" ) . gte ( \"population\" , 1000 ) . lt ( \"population\" , 10000 )","title":"Filter queries"},{"location":"examples/queries/simple-queries/","text":"Simple-style Queries # This style of querying reads almost like SQL, making most queries easier to write using this style. Multiple conditions can also be joined together using AND/OR clauses in this style, which is not possible in the filter style queries. Tip If you have difficulty choosing, just pick this style of queries \ud83d\ude09. It can do everything the filter-style queries can do, and more! Tip Refer the PostgREST docs for more info about operators. Simple example # from pgrest import Column res = await client . from_ ( \"countries\" ) . select ( \"*\" ) . where ( Column ( \"name\" ) == \"India\" ) Note The comparison operators ( == , != , > , < , <= , >= ) have been implemented directly as Python operators, although they also have equivalent methods on the Column class. That is, Column(\"name\") == \"India\" and Column(\"name\").eq(\"India\") are both valid. Join conditions with an OR/AND clause # res = await client . from_ ( \"countries\" ) . select ( \"*\" ) . where ( Column ( \"capital\" ) == \"Rome\" | Column ( \"capital\" ) == \"Berlin\" ) . execute () res = await client . from_ ( \"countries\" ) . select ( \"*\" ) . where ( Column ( \"continent\" ) == \"Asia\" & Column ( \"population\" ) >= 5000000 ) . execute () res = await client . from_ ( \"countries\" ) . select ( \"*\" ) . where ( Column ( \"continent\" ) == \"Asia\" & Column ( \"population\" ) >= 5000000 | Column ( \"name\" ) . ilike ( \" %s tan\" )) . execute () Tip In case both AND ( & ) and OR ( | ) appear in the query, the order of precedence is to first evalute AND, then OR.","title":"Simple-style Queries"},{"location":"examples/queries/simple-queries/#simple-style-queries","text":"This style of querying reads almost like SQL, making most queries easier to write using this style. Multiple conditions can also be joined together using AND/OR clauses in this style, which is not possible in the filter style queries. Tip If you have difficulty choosing, just pick this style of queries \ud83d\ude09. It can do everything the filter-style queries can do, and more! Tip Refer the PostgREST docs for more info about operators.","title":"Simple-style Queries"},{"location":"examples/queries/simple-queries/#simple-example","text":"from pgrest import Column res = await client . from_ ( \"countries\" ) . select ( \"*\" ) . where ( Column ( \"name\" ) == \"India\" ) Note The comparison operators ( == , != , > , < , <= , >= ) have been implemented directly as Python operators, although they also have equivalent methods on the Column class. That is, Column(\"name\") == \"India\" and Column(\"name\").eq(\"India\") are both valid.","title":"Simple example"},{"location":"examples/queries/simple-queries/#join-conditions-with-an-orand-clause","text":"res = await client . from_ ( \"countries\" ) . select ( \"*\" ) . where ( Column ( \"capital\" ) == \"Rome\" | Column ( \"capital\" ) == \"Berlin\" ) . execute () res = await client . from_ ( \"countries\" ) . select ( \"*\" ) . where ( Column ( \"continent\" ) == \"Asia\" & Column ( \"population\" ) >= 5000000 ) . execute () res = await client . from_ ( \"countries\" ) . select ( \"*\" ) . where ( Column ( \"continent\" ) == \"Asia\" & Column ( \"population\" ) >= 5000000 | Column ( \"name\" ) . ilike ( \" %s tan\" )) . execute () Tip In case both AND ( & ) and OR ( | ) appear in the query, the order of precedence is to first evalute AND, then OR.","title":"Join conditions with an OR/AND clause"},{"location":"reference/builders/","text":"Request Builders # pgrest.request_builder.RequestBuilder # select ( self , * columns , * , count = None ) # Run a SELECT query to fetch data. Parameters: Name Type Description Default columns str The names of columns to retrieve. Pass * for all columns. () count Optional[CountMethod] The method to be used to get the count of records that will be returned. One of \"exact\", \"planned\" or \"estimated\". None Returns: Type Description SelectRequestBuilder SelectRequestBuilder insert ( self , row , * , count = None , upsert = False ) # Run an INSERT query to add data to a table. Parameters: Name Type Description Default row dict The row to be inserted, as a dictionary, with the column names as keys. required count Optional[CountMethod] The method to be used to get the count of records that will be returned. One of \"exact\", \"planned\" or \"estimated\". None upsert bool Whether to run an upsert. False Returns: Type Description QueryRequestBuilder QueryRequestBuilder insert_many ( self , rows , * , count = None , upsert = False ) # Insert multiple rows to the same table at once. Parameters: Name Type Description Default rows list[dict] The list of rows to be inserted, where each row is a dictionary, with the column names as keys. required count Optional[CountMethod] The method to be used to get the count of records that will be returned. One of \"exact\", \"planned\" or \"estimated\". None upsert bool Whether to run an upsert. False Returns: Type Description QueryRequestBuilder QueryRequestBuilder update ( self , data , * , count = None ) # Run an UPDATE query. Parameters: Name Type Description Default data dict The new row data, as a dictionary, with the column names as keys. required count Optional[CountMethod] The method to be used to get the count of records that will be returned. One of \"exact\", \"planned\" or \"estimated\". None Returns: Type Description FilterRequestBuilder FilterRequestBuilder delete ( self , * , count = None ) # Run a DELETE query to remove rows from a table. Parameters: Name Type Description Default count Optional[CountMethod] The method to be used to get the count of records that will be returned. One of \"exact\", \"planned\" or \"estimated\". None Returns: Type Description FilterRequestBuilder FilterRequestBuilder pgrest.request_builder.QueryRequestBuilder # execute ( self ) # Execute a query to get the response. Returns: Type Description TableResponse A two-tuple, with the first element being the rows returned, and the second element being the count. pgrest.request_builder.FilterRequestBuilder ( QueryRequestBuilder ) # not_ property readonly # Negate the next filter that is applied. where ( self , condition ) # Apply filters to your query, equivalent to the WHERE clause in SQL. Parameters: Name Type Description Default condition Condition The filter conditions to apply required Returns: Type Description FilterRequestBuilder FilterRequestBuilder Examples: from pgrest import Column # single filter res = await client . from_ ( \"countries\" ) . select ( \"*\" ) . where ( Column ( \"name\" ) == \"India\" ) # filters can also be chained into a long condition res = await client . from_ ( \"countries\" ) . select ( \"*\" ) . where ( Column ( \"name\" ) == \"India\" & Column ( \"population\" ) > 100000 ) Note This form of querying turns out to be more clear in some cases, but in some cases, using the filter method might be better. filter ( self , column , operator , criteria ) # Apply filters to your query, equivalent to the WHERE clause in SQL. Parameters: Name Type Description Default column str The column to filter by. required operator str The operator to filter with. required criteria str The value to filter with. required Returns: Type Description FilterRequestBuilder FilterRequestBuilder Examples: # single filter res = await client . from_ ( \"countries\" ) . select ( \"*\" ) . filter ( \"name\" , \"eq\" , \"India\" ) . execute () # filters can be chained res = await client . from_ ( \"countries\" ) . select ( \"*\" ) . eq ( \"name\" , \"India\" ) . ilike ( \"capital\" , \" %e l%\" ) . execute () Note The filter methods all return an instance of FilterRequestBuilder, allowing for rich chaining of filters. Tip Refer the PostgREST docs for more info about operators. eq ( self , column , value ) # Operator: \"equals to\" neq ( self , column , value ) # Operator: \"not equal to\" gt ( self , column , value ) # Operator: \"greater than\" gte ( self , column , value ) # Operator: \"greater than or equal to\" lt ( self , column , value ) # Operator: \"less than\" lte ( self , column , value ) # Operator: \"less than or equal to\" is_ ( self , column , value ) # Operator: \"is\" (checking for exact equality, like null, true, false) like ( self , column , pattern ) # Operator: \"like\" for matching based on patterns ilike ( self , column , pattern ) # Operator: \"ilike\", case-insensitive LIKE. fts ( self , column , query ) # Operator: Full-Text search, using to_tsquery plfts ( self , column , query ) # Operator: Full-Text search using plainto_tsquery phfts ( self , column , query ) # Operator: Full-Text search using phraseto_tsquery wfts ( self , column , query ) # Operator: Full-Text search using websearch_to_tsquery in_ ( self , column , values ) # Operator: \"in\". Check if column is in values cs ( self , column , values ) # Operator: contains cd ( self , column , values ) # Operator: contained in ov ( self , column , values ) # Operator: overlap (have points in common) sl ( self , column , range ) # Operator: strictly left of sr ( self , column , range ) # Operator: strictly right of nxl ( self , column , range ) # Operator: does not extend to the left of nxr ( self , column , range ) # Operator: does not extend to the right of adj ( self , column , range ) # Operator: is adjacent to pgrest.request_builder.SelectRequestBuilder ( FilterRequestBuilder ) # order ( self , column , * , desc = False , nullsfirst = False ) # Sort the query response in some order. Equivalent to SQL ORDER BY column ASC | DESC Parameters: Name Type Description Default column str Name of the column to sort by required desc bool Whether to sort in descending order False nullsfirst bool Nulls first False Returns: Type Description SelectRequestBuilder SelectRequestBuilder limit ( self , size , * , start = 0 ) # Limit the number of rows returned by the query. Parameters: Name Type Description Default size int The number of rows to return required start int The index of rows to start from (OFFSET) 0 Returns: Type Description SelectRequestBuilder SelectRequestBuilder range ( self , start , end ) # Retrieve only rows in a specific range. Parameters: Name Type Description Default start int The index of rows to start from required end int The index of the last row to retrieve required Returns: Type Description SelectRequestBuilder SelectRequestBuilder single ( self ) # Return only a single row. Warning This method will raise an error if the query matched more than one valid row.","title":"Query Builders"},{"location":"reference/builders/#request-builders","text":"","title":"Request Builders"},{"location":"reference/builders/#pgrest.request_builder.RequestBuilder","text":"","title":"RequestBuilder"},{"location":"reference/builders/#pgrest.request_builder.RequestBuilder.select","text":"Run a SELECT query to fetch data. Parameters: Name Type Description Default columns str The names of columns to retrieve. Pass * for all columns. () count Optional[CountMethod] The method to be used to get the count of records that will be returned. One of \"exact\", \"planned\" or \"estimated\". None Returns: Type Description SelectRequestBuilder SelectRequestBuilder","title":"select()"},{"location":"reference/builders/#pgrest.request_builder.RequestBuilder.insert","text":"Run an INSERT query to add data to a table. Parameters: Name Type Description Default row dict The row to be inserted, as a dictionary, with the column names as keys. required count Optional[CountMethod] The method to be used to get the count of records that will be returned. One of \"exact\", \"planned\" or \"estimated\". None upsert bool Whether to run an upsert. False Returns: Type Description QueryRequestBuilder QueryRequestBuilder","title":"insert()"},{"location":"reference/builders/#pgrest.request_builder.RequestBuilder.insert_many","text":"Insert multiple rows to the same table at once. Parameters: Name Type Description Default rows list[dict] The list of rows to be inserted, where each row is a dictionary, with the column names as keys. required count Optional[CountMethod] The method to be used to get the count of records that will be returned. One of \"exact\", \"planned\" or \"estimated\". None upsert bool Whether to run an upsert. False Returns: Type Description QueryRequestBuilder QueryRequestBuilder","title":"insert_many()"},{"location":"reference/builders/#pgrest.request_builder.RequestBuilder.update","text":"Run an UPDATE query. Parameters: Name Type Description Default data dict The new row data, as a dictionary, with the column names as keys. required count Optional[CountMethod] The method to be used to get the count of records that will be returned. One of \"exact\", \"planned\" or \"estimated\". None Returns: Type Description FilterRequestBuilder FilterRequestBuilder","title":"update()"},{"location":"reference/builders/#pgrest.request_builder.RequestBuilder.delete","text":"Run a DELETE query to remove rows from a table. Parameters: Name Type Description Default count Optional[CountMethod] The method to be used to get the count of records that will be returned. One of \"exact\", \"planned\" or \"estimated\". None Returns: Type Description FilterRequestBuilder FilterRequestBuilder","title":"delete()"},{"location":"reference/builders/#pgrest.request_builder.QueryRequestBuilder","text":"","title":"QueryRequestBuilder"},{"location":"reference/builders/#pgrest.request_builder.QueryRequestBuilder.execute","text":"Execute a query to get the response. Returns: Type Description TableResponse A two-tuple, with the first element being the rows returned, and the second element being the count.","title":"execute()"},{"location":"reference/builders/#pgrest.request_builder.FilterRequestBuilder","text":"","title":"FilterRequestBuilder"},{"location":"reference/builders/#pgrest.request_builder.FilterRequestBuilder.not_","text":"Negate the next filter that is applied.","title":"not_"},{"location":"reference/builders/#pgrest.request_builder.FilterRequestBuilder.where","text":"Apply filters to your query, equivalent to the WHERE clause in SQL. Parameters: Name Type Description Default condition Condition The filter conditions to apply required Returns: Type Description FilterRequestBuilder FilterRequestBuilder Examples: from pgrest import Column # single filter res = await client . from_ ( \"countries\" ) . select ( \"*\" ) . where ( Column ( \"name\" ) == \"India\" ) # filters can also be chained into a long condition res = await client . from_ ( \"countries\" ) . select ( \"*\" ) . where ( Column ( \"name\" ) == \"India\" & Column ( \"population\" ) > 100000 ) Note This form of querying turns out to be more clear in some cases, but in some cases, using the filter method might be better.","title":"where()"},{"location":"reference/builders/#pgrest.request_builder.FilterRequestBuilder.filter","text":"Apply filters to your query, equivalent to the WHERE clause in SQL. Parameters: Name Type Description Default column str The column to filter by. required operator str The operator to filter with. required criteria str The value to filter with. required Returns: Type Description FilterRequestBuilder FilterRequestBuilder Examples: # single filter res = await client . from_ ( \"countries\" ) . select ( \"*\" ) . filter ( \"name\" , \"eq\" , \"India\" ) . execute () # filters can be chained res = await client . from_ ( \"countries\" ) . select ( \"*\" ) . eq ( \"name\" , \"India\" ) . ilike ( \"capital\" , \" %e l%\" ) . execute () Note The filter methods all return an instance of FilterRequestBuilder, allowing for rich chaining of filters. Tip Refer the PostgREST docs for more info about operators.","title":"filter()"},{"location":"reference/builders/#pgrest.request_builder.FilterRequestBuilder.eq","text":"Operator: \"equals to\"","title":"eq()"},{"location":"reference/builders/#pgrest.request_builder.FilterRequestBuilder.neq","text":"Operator: \"not equal to\"","title":"neq()"},{"location":"reference/builders/#pgrest.request_builder.FilterRequestBuilder.gt","text":"Operator: \"greater than\"","title":"gt()"},{"location":"reference/builders/#pgrest.request_builder.FilterRequestBuilder.gte","text":"Operator: \"greater than or equal to\"","title":"gte()"},{"location":"reference/builders/#pgrest.request_builder.FilterRequestBuilder.lt","text":"Operator: \"less than\"","title":"lt()"},{"location":"reference/builders/#pgrest.request_builder.FilterRequestBuilder.lte","text":"Operator: \"less than or equal to\"","title":"lte()"},{"location":"reference/builders/#pgrest.request_builder.FilterRequestBuilder.is_","text":"Operator: \"is\" (checking for exact equality, like null, true, false)","title":"is_()"},{"location":"reference/builders/#pgrest.request_builder.FilterRequestBuilder.like","text":"Operator: \"like\" for matching based on patterns","title":"like()"},{"location":"reference/builders/#pgrest.request_builder.FilterRequestBuilder.ilike","text":"Operator: \"ilike\", case-insensitive LIKE.","title":"ilike()"},{"location":"reference/builders/#pgrest.request_builder.FilterRequestBuilder.fts","text":"Operator: Full-Text search, using to_tsquery","title":"fts()"},{"location":"reference/builders/#pgrest.request_builder.FilterRequestBuilder.plfts","text":"Operator: Full-Text search using plainto_tsquery","title":"plfts()"},{"location":"reference/builders/#pgrest.request_builder.FilterRequestBuilder.phfts","text":"Operator: Full-Text search using phraseto_tsquery","title":"phfts()"},{"location":"reference/builders/#pgrest.request_builder.FilterRequestBuilder.wfts","text":"Operator: Full-Text search using websearch_to_tsquery","title":"wfts()"},{"location":"reference/builders/#pgrest.request_builder.FilterRequestBuilder.in_","text":"Operator: \"in\". Check if column is in values","title":"in_()"},{"location":"reference/builders/#pgrest.request_builder.FilterRequestBuilder.cs","text":"Operator: contains","title":"cs()"},{"location":"reference/builders/#pgrest.request_builder.FilterRequestBuilder.cd","text":"Operator: contained in","title":"cd()"},{"location":"reference/builders/#pgrest.request_builder.FilterRequestBuilder.ov","text":"Operator: overlap (have points in common)","title":"ov()"},{"location":"reference/builders/#pgrest.request_builder.FilterRequestBuilder.sl","text":"Operator: strictly left of","title":"sl()"},{"location":"reference/builders/#pgrest.request_builder.FilterRequestBuilder.sr","text":"Operator: strictly right of","title":"sr()"},{"location":"reference/builders/#pgrest.request_builder.FilterRequestBuilder.nxl","text":"Operator: does not extend to the left of","title":"nxl()"},{"location":"reference/builders/#pgrest.request_builder.FilterRequestBuilder.nxr","text":"Operator: does not extend to the right of","title":"nxr()"},{"location":"reference/builders/#pgrest.request_builder.FilterRequestBuilder.adj","text":"Operator: is adjacent to","title":"adj()"},{"location":"reference/builders/#pgrest.request_builder.SelectRequestBuilder","text":"","title":"SelectRequestBuilder"},{"location":"reference/builders/#pgrest.request_builder.SelectRequestBuilder.order","text":"Sort the query response in some order. Equivalent to SQL ORDER BY column ASC | DESC Parameters: Name Type Description Default column str Name of the column to sort by required desc bool Whether to sort in descending order False nullsfirst bool Nulls first False Returns: Type Description SelectRequestBuilder SelectRequestBuilder","title":"order()"},{"location":"reference/builders/#pgrest.request_builder.SelectRequestBuilder.limit","text":"Limit the number of rows returned by the query. Parameters: Name Type Description Default size int The number of rows to return required start int The index of rows to start from (OFFSET) 0 Returns: Type Description SelectRequestBuilder SelectRequestBuilder","title":"limit()"},{"location":"reference/builders/#pgrest.request_builder.SelectRequestBuilder.range","text":"Retrieve only rows in a specific range. Parameters: Name Type Description Default start int The index of rows to start from required end int The index of the last row to retrieve required Returns: Type Description SelectRequestBuilder SelectRequestBuilder","title":"range()"},{"location":"reference/builders/#pgrest.request_builder.SelectRequestBuilder.single","text":"Return only a single row. Warning This method will raise an error if the query matched more than one valid row.","title":"single()"},{"location":"reference/client/","text":"Client # pgrest.async_client.Client ( BaseClient ) # Asyncio compatible PostgREST client. __init__ ( self , base_url , * , schema = 'public' , headers = { 'Accept' : 'application/json' , 'Content-Type' : 'application/json' }, session = None ) special # Create a PostgREST client. Parameters: Name Type Description Default base_url str base URL of the PostgREST API. required schema str Which database schema to use. 'public' headers dict[str, str] Any headers that have to be sent with every request. {'Accept': 'application/json', 'Content-Type': 'application/json'} session Optional[_AsyncClient] instance of httpx.AsyncClient if you want to reuse an existing one. None aclose ( self ) async # Close the underlying HTTP transport and proxies. selection: inherited_members: true pgrest.base_client.BaseClient # auth ( self , token = None , * , username = None , password = '' ) # Authenticate the client with either bearer token or basic authentication. Bearer token is preferred if both ones are provided. Parameters: Name Type Description Default token Optional[str] The bearer token to authenticate with. None username Optional[AnyStr] Username None password AnyStr Password '' Returns: Type Description T The modified Client instance. Exceptions: Type Description ValueError if neither authentication scheme is provided. schema ( self , schema ) # Switch to another database schema. Parameters: Name Type Description Default schema str The name of the new schema to switch to. required Returns: Type Description T The modified Client instance. from_ ( self , table ) # Perform a table operation. Parameters: Name Type Description Default table str The name of the table to query from. required Returns: Type Description RequestBuilder RequestBuilder rpc ( self , func , params ) # Perform a stored procedure call. Parameters: Name Type Description Default func str The name of the PostgreSQL stored procedure (function) to run. required params dict Named parameters to pass to the function. required Returns: Type Description FilterRequestBuilder FilterRequestBuilder","title":"Client"},{"location":"reference/client/#client","text":"","title":"Client"},{"location":"reference/client/#pgrest.async_client.Client","text":"Asyncio compatible PostgREST client.","title":"Client"},{"location":"reference/client/#pgrest.async_client.Client.__init__","text":"Create a PostgREST client. Parameters: Name Type Description Default base_url str base URL of the PostgREST API. required schema str Which database schema to use. 'public' headers dict[str, str] Any headers that have to be sent with every request. {'Accept': 'application/json', 'Content-Type': 'application/json'} session Optional[_AsyncClient] instance of httpx.AsyncClient if you want to reuse an existing one. None","title":"__init__()"},{"location":"reference/client/#pgrest.async_client.Client.aclose","text":"Close the underlying HTTP transport and proxies. selection: inherited_members: true","title":"aclose()"},{"location":"reference/client/#pgrest.base_client.BaseClient","text":"","title":"BaseClient"},{"location":"reference/client/#pgrest.base_client.BaseClient.auth","text":"Authenticate the client with either bearer token or basic authentication. Bearer token is preferred if both ones are provided. Parameters: Name Type Description Default token Optional[str] The bearer token to authenticate with. None username Optional[AnyStr] Username None password AnyStr Password '' Returns: Type Description T The modified Client instance. Exceptions: Type Description ValueError if neither authentication scheme is provided.","title":"auth()"},{"location":"reference/client/#pgrest.base_client.BaseClient.schema","text":"Switch to another database schema. Parameters: Name Type Description Default schema str The name of the new schema to switch to. required Returns: Type Description T The modified Client instance.","title":"schema()"},{"location":"reference/client/#pgrest.base_client.BaseClient.from_","text":"Perform a table operation. Parameters: Name Type Description Default table str The name of the table to query from. required Returns: Type Description RequestBuilder RequestBuilder","title":"from_()"},{"location":"reference/client/#pgrest.base_client.BaseClient.rpc","text":"Perform a stored procedure call. Parameters: Name Type Description Default func str The name of the PostgreSQL stored procedure (function) to run. required params dict Named parameters to pass to the function. required Returns: Type Description FilterRequestBuilder FilterRequestBuilder","title":"rpc()"},{"location":"reference/query/","text":"Simple Querying Classes # pgrest.query.Column # Represents a column to use while querying. Tip Refer the PostgREST docs for more info about operators. eq ( self , value ) # Operator: \"equals to\" Note This is an alternative to doing Column(x) == value neq ( self , value ) # Operator: \"not equal to\" Note This is an alternative to doing Column(x) != value gt ( self , value ) # Operator: \"greater than\" Note This is an alternative to doing Column(x) > value gte ( self , value ) # Operator: \"greater than or equal to\" Note This is an alternative to doing Column(x) >= value lt ( self , value ) # Operator: \"less than\" Note This is an alternative to doing Column(x) < value lte ( self , value ) # Operator: \"less than or equal to\" Note This is an alternative to doing Column(x) <= value is_ ( self , value ) # Compares for exact equality (for null/true/false). like ( self , pattern ) # SQL \"LIKE\" operator. ilike ( self , pattern ) # Case insensitive \"LIKE\" operator. in_ ( self , values ) # Check if the column value is one of a list of values. fts ( self , query ) # Full-text search using to_tsquery plfts ( self , query ) # Operator: Full-Text search using plainto_tsquery phfts ( self , query ) # Operator: Full-Text search using phraseto_tsquery wfts ( self , query ) # Operator: Full-Text search using websearch_to_tsquery cs ( self , values ) # Operator: contains cd ( self , values ) # Operator: contained in ov ( self , values ) # Operator: overlap (have points in common) sl ( self , range ) # Operator: strictly left of Note This is an alternative to doing Column(x) << (f1, f2) sr ( self , range ) # Operator: strictly right of Note This is an alternative to doing Column(x) >> (f1, f2) nxl ( self , range ) # Operator: does not extend to the left of nxr ( self , range ) # Operator: does not extend to the right of adj ( self , range ) # Operator: is adjacent to pgrest.query.Condition # Represents a query condition. Warning This class is not meant to be constructed directly, nor is it part of the public API of this library. Instances of this class are returned by methods on the Column class, and is documented here for the sake of clarity only. __and__ ( self , other ) special # Join multiple conditions using AND __or__ ( self , other ) special # Join multiple conditions using OR flatten_params ( self ) # parse self.params into a valid query string stringify ( obj ) staticmethod # recursively convert each dictionary into a string","title":"Column"},{"location":"reference/query/#simple-querying-classes","text":"","title":"Simple Querying Classes"},{"location":"reference/query/#pgrest.query.Column","text":"Represents a column to use while querying. Tip Refer the PostgREST docs for more info about operators.","title":"Column"},{"location":"reference/query/#pgrest.query.Column.eq","text":"Operator: \"equals to\" Note This is an alternative to doing Column(x) == value","title":"eq()"},{"location":"reference/query/#pgrest.query.Column.neq","text":"Operator: \"not equal to\" Note This is an alternative to doing Column(x) != value","title":"neq()"},{"location":"reference/query/#pgrest.query.Column.gt","text":"Operator: \"greater than\" Note This is an alternative to doing Column(x) > value","title":"gt()"},{"location":"reference/query/#pgrest.query.Column.gte","text":"Operator: \"greater than or equal to\" Note This is an alternative to doing Column(x) >= value","title":"gte()"},{"location":"reference/query/#pgrest.query.Column.lt","text":"Operator: \"less than\" Note This is an alternative to doing Column(x) < value","title":"lt()"},{"location":"reference/query/#pgrest.query.Column.lte","text":"Operator: \"less than or equal to\" Note This is an alternative to doing Column(x) <= value","title":"lte()"},{"location":"reference/query/#pgrest.query.Column.is_","text":"Compares for exact equality (for null/true/false).","title":"is_()"},{"location":"reference/query/#pgrest.query.Column.like","text":"SQL \"LIKE\" operator.","title":"like()"},{"location":"reference/query/#pgrest.query.Column.ilike","text":"Case insensitive \"LIKE\" operator.","title":"ilike()"},{"location":"reference/query/#pgrest.query.Column.in_","text":"Check if the column value is one of a list of values.","title":"in_()"},{"location":"reference/query/#pgrest.query.Column.fts","text":"Full-text search using to_tsquery","title":"fts()"},{"location":"reference/query/#pgrest.query.Column.plfts","text":"Operator: Full-Text search using plainto_tsquery","title":"plfts()"},{"location":"reference/query/#pgrest.query.Column.phfts","text":"Operator: Full-Text search using phraseto_tsquery","title":"phfts()"},{"location":"reference/query/#pgrest.query.Column.wfts","text":"Operator: Full-Text search using websearch_to_tsquery","title":"wfts()"},{"location":"reference/query/#pgrest.query.Column.cs","text":"Operator: contains","title":"cs()"},{"location":"reference/query/#pgrest.query.Column.cd","text":"Operator: contained in","title":"cd()"},{"location":"reference/query/#pgrest.query.Column.ov","text":"Operator: overlap (have points in common)","title":"ov()"},{"location":"reference/query/#pgrest.query.Column.sl","text":"Operator: strictly left of Note This is an alternative to doing Column(x) << (f1, f2)","title":"sl()"},{"location":"reference/query/#pgrest.query.Column.sr","text":"Operator: strictly right of Note This is an alternative to doing Column(x) >> (f1, f2)","title":"sr()"},{"location":"reference/query/#pgrest.query.Column.nxl","text":"Operator: does not extend to the left of","title":"nxl()"},{"location":"reference/query/#pgrest.query.Column.nxr","text":"Operator: does not extend to the right of","title":"nxr()"},{"location":"reference/query/#pgrest.query.Column.adj","text":"Operator: is adjacent to","title":"adj()"},{"location":"reference/query/#pgrest.query.Condition","text":"Represents a query condition. Warning This class is not meant to be constructed directly, nor is it part of the public API of this library. Instances of this class are returned by methods on the Column class, and is documented here for the sake of clarity only.","title":"Condition"},{"location":"reference/query/#pgrest.query.Condition.__and__","text":"Join multiple conditions using AND","title":"__and__()"},{"location":"reference/query/#pgrest.query.Condition.__or__","text":"Join multiple conditions using OR","title":"__or__()"},{"location":"reference/query/#pgrest.query.Condition.flatten_params","text":"parse self.params into a valid query string","title":"flatten_params()"},{"location":"reference/query/#pgrest.query.Condition.stringify","text":"recursively convert each dictionary into a string","title":"stringify()"}]}